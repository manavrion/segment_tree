{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Segment tree A generic segment tree C++ header-only library. How to build git clone git@github.com :manavrion/segment_tree.git ./build.sh Clang compiler sudo bash -c \"$(wget -O - https://apt.llvm.org/llvm.sh )\" update-alternatives \u2013install /usr/bin/clang clang /usr/bin/clang-10 10 update-alternatives \u2013install /usr/bin/clang++ clang++ /usr/bin/clang++-10 10 How to test ./test.sh","title":"Segment tree"},{"location":"#segment-tree","text":"A generic segment tree C++ header-only library.","title":"Segment tree"},{"location":"#how-to-build","text":"git clone git@github.com :manavrion/segment_tree.git ./build.sh","title":"How to build"},{"location":"#clang-compiler","text":"sudo bash -c \"$(wget -O - https://apt.llvm.org/llvm.sh )\" update-alternatives \u2013install /usr/bin/clang clang /usr/bin/clang-10 10 update-alternatives \u2013install /usr/bin/clang++ clang++ /usr/bin/clang++-10 10","title":"Clang compiler"},{"location":"#how-to-test","text":"./test.sh","title":"How to test"},{"location":"examples/examples/","text":"Default functor // std::plus functor will be used at segment_tree by default. segment_tree < int > st = { 0 , 1 , 2 , 3 , 4 }; // Finds a minimum value in [2, 5) range. // Time complexity - O(log n) where \"n\" is st.size(). std :: cout << st . query ( 2 , 5 ) << std :: endl ; // Prints: 9 // Rewrites a value located at index 2 with value 5. // Time complexity - O(log n) where \"n\" is st.size(). st . update ( 2 , 5 ); std :: cout << st . query ( 2 , 5 ) << std :: endl ; // Prints: 12 Custom functor // You can use custom functors. segment_tree < int , std :: multiplies < int >> st ({ 0 , 1 , 2 , 3 , 4 }); std :: cout << st . query ( 2 , 5 ) << std :: endl ; // Prints: 24 Combined functor // You can combine operations. // To achieve it, you have to define reducer and mapper. auto reducer = []( auto lhs , auto rhs ) { return std :: make_pair ( lhs . first + rhs . first , lhs . second * rhs . second ); }; auto mapper = []( auto arg ) { return std :: make_pair ( arg , arg ); }; mapped_segment_tree < int , decltype ( reducer ), decltype ( mapper ) > st ( { 0 , 1 , 2 , 3 , 4 }, reducer , mapper ); auto result = st . query ( 2 , 5 ); std :: cout << \"sum: \" << result . first << std :: endl ; // Prints: \"sum: 9\" std :: cout << \"mul: \" << result . second << std :: endl ; // Prints: \"mul: 24\"","title":"Default functor"},{"location":"examples/examples/#default-functor","text":"// std::plus functor will be used at segment_tree by default. segment_tree < int > st = { 0 , 1 , 2 , 3 , 4 }; // Finds a minimum value in [2, 5) range. // Time complexity - O(log n) where \"n\" is st.size(). std :: cout << st . query ( 2 , 5 ) << std :: endl ; // Prints: 9 // Rewrites a value located at index 2 with value 5. // Time complexity - O(log n) where \"n\" is st.size(). st . update ( 2 , 5 ); std :: cout << st . query ( 2 , 5 ) << std :: endl ; // Prints: 12","title":"Default functor"},{"location":"examples/examples/#custom-functor","text":"// You can use custom functors. segment_tree < int , std :: multiplies < int >> st ({ 0 , 1 , 2 , 3 , 4 }); std :: cout << st . query ( 2 , 5 ) << std :: endl ; // Prints: 24","title":"Custom functor"},{"location":"examples/examples/#combined-functor","text":"// You can combine operations. // To achieve it, you have to define reducer and mapper. auto reducer = []( auto lhs , auto rhs ) { return std :: make_pair ( lhs . first + rhs . first , lhs . second * rhs . second ); }; auto mapper = []( auto arg ) { return std :: make_pair ( arg , arg ); }; mapped_segment_tree < int , decltype ( reducer ), decltype ( mapper ) > st ( { 0 , 1 , 2 , 3 , 4 }, reducer , mapper ); auto result = st . query ( 2 , 5 ); std :: cout << \"sum: \" << result . first << std :: endl ; // Prints: \"sum: 9\" std :: cout << \"mul: \" << result . second << std :: endl ; // Prints: \"mul: 24\"","title":"Combined functor"},{"location":"paper/traversing/","text":"Traversing Top-down graph TD 0 -->|0 * 2 + 1| 1 0 -->|0 * 2 + 2| 2 1 -->|1 * 2 + 1| 3 1 -->|1 * 2 + 2| 4 2 -->|2 * 2 + 1| 5 2 -->|2 * 2 + 2| 6 3 -->|3 * 2 + 1 - 7| v0[0]:::plain 3 -->|3 * 2 + 2 - 7| v1[1]:::plain 4 -->|4 * 2 + 1 - 7| v2[2]:::plain 4 -->|4 * 2 + 2 - 7| v3[3]:::plain 5 -->|5 * 2 + 1 - 7| v4[4]:::plain 5 -->|5 * 2 + 2 - 7| v5[5]:::plain 6 -->|6 * 2 + 1 - 7| v6[6]:::plain 6 -->|6 * 2 + 2 - 7| v7[7]:::plain classDef plain fill:#fff; Traversing at tree left_child = i*2 + 1 right_child = i*2 + 2 Traversing from tree to the plain data shift = 3 shift_down = 7 left_child = i*2 + 1 - shift_down right_child = i*2 + 2 - shift_down Down-top graph TD 1 -->|\"(1 - 1) / 2\"| 0 2 -->|\"(2 - 1) / 2\"| 0 3 -->|\"(3 - 1) / 2\"| 1 4 -->|\"(4 - 1) / 2\"| 1 5 -->|\"(5 - 1) / 2\"| 2 6 -->|\"(6 - 1) / 2\"| 2 v0[0]:::plain -->|\"(0 + 7 - 1) / 2\"| 3 v1[1]:::plain -->|\"(1 + 7 - 1) / 2\"| 3 v2[2]:::plain -->|\"(2 + 7 - 1) / 2\"| 4 v3[3]:::plain -->|\"(3 + 7 - 1) / 2\"| 4 v4[4]:::plain -->|\"(4 + 7 - 1) / 2\"| 5 v5[5]:::plain -->|\"(5 + 7 - 1) / 2\"| 5 v6[6]:::plain -->|\"(6 + 7 - 1) / 2\"| 6 v7[7]:::plain -->|\"(7 + 7 - 1) / 2\"| 6 classDef plain fill:#fff; Traversing at tree parent = (i - 1) / 2 Traversing from tree to the plain data shift = 3 shift_down = 7 parent = (j + shift_down - 1) / 2","title":"Traversing"},{"location":"paper/traversing/#traversing","text":"","title":"Traversing"},{"location":"paper/traversing/#top-down","text":"graph TD 0 -->|0 * 2 + 1| 1 0 -->|0 * 2 + 2| 2 1 -->|1 * 2 + 1| 3 1 -->|1 * 2 + 2| 4 2 -->|2 * 2 + 1| 5 2 -->|2 * 2 + 2| 6 3 -->|3 * 2 + 1 - 7| v0[0]:::plain 3 -->|3 * 2 + 2 - 7| v1[1]:::plain 4 -->|4 * 2 + 1 - 7| v2[2]:::plain 4 -->|4 * 2 + 2 - 7| v3[3]:::plain 5 -->|5 * 2 + 1 - 7| v4[4]:::plain 5 -->|5 * 2 + 2 - 7| v5[5]:::plain 6 -->|6 * 2 + 1 - 7| v6[6]:::plain 6 -->|6 * 2 + 2 - 7| v7[7]:::plain classDef plain fill:#fff;","title":"Top-down"},{"location":"paper/traversing/#traversing-at-tree","text":"left_child = i*2 + 1 right_child = i*2 + 2","title":"Traversing at tree"},{"location":"paper/traversing/#traversing-from-tree-to-the-plain-data","text":"shift = 3 shift_down = 7 left_child = i*2 + 1 - shift_down right_child = i*2 + 2 - shift_down","title":"Traversing from tree to the plain data"},{"location":"paper/traversing/#down-top","text":"graph TD 1 -->|\"(1 - 1) / 2\"| 0 2 -->|\"(2 - 1) / 2\"| 0 3 -->|\"(3 - 1) / 2\"| 1 4 -->|\"(4 - 1) / 2\"| 1 5 -->|\"(5 - 1) / 2\"| 2 6 -->|\"(6 - 1) / 2\"| 2 v0[0]:::plain -->|\"(0 + 7 - 1) / 2\"| 3 v1[1]:::plain -->|\"(1 + 7 - 1) / 2\"| 3 v2[2]:::plain -->|\"(2 + 7 - 1) / 2\"| 4 v3[3]:::plain -->|\"(3 + 7 - 1) / 2\"| 4 v4[4]:::plain -->|\"(4 + 7 - 1) / 2\"| 5 v5[5]:::plain -->|\"(5 + 7 - 1) / 2\"| 5 v6[6]:::plain -->|\"(6 + 7 - 1) / 2\"| 6 v7[7]:::plain -->|\"(7 + 7 - 1) / 2\"| 6 classDef plain fill:#fff;","title":"Down-top"},{"location":"paper/traversing/#traversing-at-tree_1","text":"parent = (i - 1) / 2","title":"Traversing at tree"},{"location":"paper/traversing/#traversing-from-tree-to-the-plain-data_1","text":"shift = 3 shift_down = 7 parent = (j + shift_down - 1) / 2","title":"Traversing from tree to the plain data"},{"location":"paper/tree/","text":"Tree Classic segment tree structure graph TD 0 --> 1 0 --> 2 1 --> 3 1 --> 4 2 --> 5 2 --> 6 3 --> 7 3 --> 8 4 --> 9 4 --> 10 5 --> 11 5 --> 12 6 --> 13 6 --> 14 Used format graph TD 0 --> 1 0 --> 2 1 --> 3 1 --> 4 2 --> 5 2 --> 6 3 --> v0[0]:::plain 3 --> v1[1]:::plain 4 --> v2[2]:::plain 4 --> v3[3]:::plain 5 --> v4[4]:::plain 5 --> v5[5]:::plain 6 --> v6[6]:::plain 6 --> v7[7]:::plain classDef plain fill:#fff; Let's define 'shift' value as an index of the left-bottom node of a given tree. For this case, 'shift' equals to 3. Also, we can define 'shift_up' and 'shift_down' operations. shift_up = shift / 2 shift_down = shift * 2 + 1","title":"Tree"},{"location":"paper/tree/#tree","text":"","title":"Tree"},{"location":"paper/tree/#classic-segment-tree-structure","text":"graph TD 0 --> 1 0 --> 2 1 --> 3 1 --> 4 2 --> 5 2 --> 6 3 --> 7 3 --> 8 4 --> 9 4 --> 10 5 --> 11 5 --> 12 6 --> 13 6 --> 14","title":"Classic segment tree structure"},{"location":"paper/tree/#used-format","text":"graph TD 0 --> 1 0 --> 2 1 --> 3 1 --> 4 2 --> 5 2 --> 6 3 --> v0[0]:::plain 3 --> v1[1]:::plain 4 --> v2[2]:::plain 4 --> v3[3]:::plain 5 --> v4[4]:::plain 5 --> v5[5]:::plain 6 --> v6[6]:::plain 6 --> v7[7]:::plain classDef plain fill:#fff; Let's define 'shift' value as an index of the left-bottom node of a given tree. For this case, 'shift' equals to 3. Also, we can define 'shift_up' and 'shift_down' operations. shift_up = shift / 2 shift_down = shift * 2 + 1","title":"Used format"}]}